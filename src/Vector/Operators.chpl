
//
// Autogenerated by generate_ops.py: DO NOT EDIT
//
module Operators {
  use Vector only vector;
  import Intrin;

  /*
    Implements ``VECTOR + VECTOR``

    See :proc:`Intrin.add` for the intrinsic used.
  */
  inline operator+(x: vector(?eltType, ?numElts), y: x.type): x.type {
    var result: x.type;
    result.data = Intrin.add(eltType, numElts, x.data, y.data);
    return result;
  }

  /*
    Implements ``VECTOR += VECTOR``

    See :proc:`Intrin.add` for the intrinsic used.
  */
  inline operator+=(ref x: vector(?eltType, ?numElts), y: x.type) {
    x.data = Intrin.add(eltType, numElts, x.data, y.data);
  }

  /*
    Implements ``VECTOR + SCALAR``

    See :proc:`Intrin.add` for the intrinsic used.
  */
  inline operator+(x: vector(?eltType, ?numElts), y: ?scalarType): x.type
    where isCoercible(scalarType, eltType) {
    var result: x.type;
    result.data = Intrin.add(eltType, numElts, x.data,
                    Intrin.splat(eltType, numElts, y));
    return result;
  }

  /*
    Implements ``VECTOR += SCALAR``

    See :proc:`Intrin.add` for the intrinsic used.
  */
  inline operator+=(ref x: vector(?eltType, ?numElts), y: ?scalarType)
    where isCoercible(scalarType, eltType) {
    x.data = Intrin.add(eltType, numElts, x.data,
                    Intrin.splat(eltType, numElts, y));
  }

  /*
    Implements ``SCALAR + VECTOR``

    See :proc:`Intrin.add` for the intrinsic used.
  */
  inline operator+(x: ?scalarType, y: vector(?eltType, ?numElts)): y.type
    where isCoercible(scalarType, eltType) {
    var result: y.type;
    result.data = Intrin.add(eltType, numElts,
                    Intrin.splat(eltType, numElts, x), y.data);
    return result;
  }

  /*
    Implements ``VECTOR - VECTOR``

    See :proc:`Intrin.sub` for the intrinsic used.
  */
  inline operator-(x: vector(?eltType, ?numElts), y: x.type): x.type {
    var result: x.type;
    result.data = Intrin.sub(eltType, numElts, x.data, y.data);
    return result;
  }

  /*
    Implements ``VECTOR -= VECTOR``

    See :proc:`Intrin.sub` for the intrinsic used.
  */
  inline operator-=(ref x: vector(?eltType, ?numElts), y: x.type) {
    x.data = Intrin.sub(eltType, numElts, x.data, y.data);
  }

  /*
    Implements ``VECTOR - SCALAR``

    See :proc:`Intrin.sub` for the intrinsic used.
  */
  inline operator-(x: vector(?eltType, ?numElts), y: ?scalarType): x.type
    where isCoercible(scalarType, eltType) {
    var result: x.type;
    result.data = Intrin.sub(eltType, numElts, x.data,
                    Intrin.splat(eltType, numElts, y));
    return result;
  }

  /*
    Implements ``VECTOR -= SCALAR``

    See :proc:`Intrin.sub` for the intrinsic used.
  */
  inline operator-=(ref x: vector(?eltType, ?numElts), y: ?scalarType)
    where isCoercible(scalarType, eltType) {
    x.data = Intrin.sub(eltType, numElts, x.data,
                    Intrin.splat(eltType, numElts, y));
  }

  /*
    Implements ``SCALAR - VECTOR``

    See :proc:`Intrin.sub` for the intrinsic used.
  */
  inline operator-(x: ?scalarType, y: vector(?eltType, ?numElts)): y.type
    where isCoercible(scalarType, eltType) {
    var result: y.type;
    result.data = Intrin.sub(eltType, numElts,
                    Intrin.splat(eltType, numElts, x), y.data);
    return result;
  }

  /*
    Implements ``VECTOR * VECTOR``

    See :proc:`Intrin.mul` for the intrinsic used.
  */
  inline operator*(x: vector(?eltType, ?numElts), y: x.type): x.type {
    var result: x.type;
    result.data = Intrin.mul(eltType, numElts, x.data, y.data);
    return result;
  }

  /*
    Implements ``VECTOR *= VECTOR``

    See :proc:`Intrin.mul` for the intrinsic used.
  */
  inline operator*=(ref x: vector(?eltType, ?numElts), y: x.type) {
    x.data = Intrin.mul(eltType, numElts, x.data, y.data);
  }

  /*
    Implements ``VECTOR * SCALAR``

    See :proc:`Intrin.mul` for the intrinsic used.
  */
  inline operator*(x: vector(?eltType, ?numElts), y: ?scalarType): x.type
    where isCoercible(scalarType, eltType) {
    var result: x.type;
    result.data = Intrin.mul(eltType, numElts, x.data,
                    Intrin.splat(eltType, numElts, y));
    return result;
  }

  /*
    Implements ``VECTOR *= SCALAR``

    See :proc:`Intrin.mul` for the intrinsic used.
  */
  inline operator*=(ref x: vector(?eltType, ?numElts), y: ?scalarType)
    where isCoercible(scalarType, eltType) {
    x.data = Intrin.mul(eltType, numElts, x.data,
                    Intrin.splat(eltType, numElts, y));
  }

  /*
    Implements ``SCALAR * VECTOR``

    See :proc:`Intrin.mul` for the intrinsic used.
  */
  inline operator*(x: ?scalarType, y: vector(?eltType, ?numElts)): y.type
    where isCoercible(scalarType, eltType) {
    var result: y.type;
    result.data = Intrin.mul(eltType, numElts,
                    Intrin.splat(eltType, numElts, x), y.data);
    return result;
  }

  /*
    Implements ``VECTOR / VECTOR``

    See :proc:`Intrin.div` for the intrinsic used.
  */
  inline operator/(x: vector(?eltType, ?numElts), y: x.type): x.type {
    var result: x.type;
    result.data = Intrin.div(eltType, numElts, x.data, y.data);
    return result;
  }

  /*
    Implements ``VECTOR /= VECTOR``

    See :proc:`Intrin.div` for the intrinsic used.
  */
  inline operator/=(ref x: vector(?eltType, ?numElts), y: x.type) {
    x.data = Intrin.div(eltType, numElts, x.data, y.data);
  }

  /*
    Implements ``VECTOR / SCALAR``

    See :proc:`Intrin.div` for the intrinsic used.
  */
  inline operator/(x: vector(?eltType, ?numElts), y: ?scalarType): x.type
    where isCoercible(scalarType, eltType) {
    var result: x.type;
    result.data = Intrin.div(eltType, numElts, x.data,
                    Intrin.splat(eltType, numElts, y));
    return result;
  }

  /*
    Implements ``VECTOR /= SCALAR``

    See :proc:`Intrin.div` for the intrinsic used.
  */
  inline operator/=(ref x: vector(?eltType, ?numElts), y: ?scalarType)
    where isCoercible(scalarType, eltType) {
    x.data = Intrin.div(eltType, numElts, x.data,
                    Intrin.splat(eltType, numElts, y));
  }

  /*
    Implements ``SCALAR / VECTOR``

    See :proc:`Intrin.div` for the intrinsic used.
  */
  inline operator/(x: ?scalarType, y: vector(?eltType, ?numElts)): y.type
    where isCoercible(scalarType, eltType) {
    var result: y.type;
    result.data = Intrin.div(eltType, numElts,
                    Intrin.splat(eltType, numElts, x), y.data);
    return result;
  }

  /*
    Implements ``VECTOR -``

    See :proc:`Intrin.neg` for the intrinsic used.
  */
  inline operator-(x: vector(?eltType, ?numElts)): x.type {
    var result: x.type;
    result.data = Intrin.neg(eltType, numElts, x.data);
    return result;
  }

  /*
    Implements ``VECTOR & VECTOR``

    See :proc:`Intrin.and` for the intrinsic used.
  */
  inline operator&(x: vector(?eltType, ?numElts), y: x.type): x.type {
    var result: x.type;
    result.data = Intrin.and(eltType, numElts, x.data, y.data);
    return result;
  }

  /*
    Implements ``VECTOR &= VECTOR``

    See :proc:`Intrin.and` for the intrinsic used.
  */
  inline operator&=(ref x: vector(?eltType, ?numElts), y: x.type) {
    x.data = Intrin.and(eltType, numElts, x.data, y.data);
  }

  /*
    Implements ``VECTOR & SCALAR``

    See :proc:`Intrin.and` for the intrinsic used.
  */
  inline operator&(x: vector(?eltType, ?numElts), y: ?scalarType): x.type
    where isCoercible(scalarType, eltType) {
    var result: x.type;
    result.data = Intrin.and(eltType, numElts, x.data,
                    Intrin.splat(eltType, numElts, y));
    return result;
  }

  /*
    Implements ``VECTOR &= SCALAR``

    See :proc:`Intrin.and` for the intrinsic used.
  */
  inline operator&=(ref x: vector(?eltType, ?numElts), y: ?scalarType)
    where isCoercible(scalarType, eltType) {
    x.data = Intrin.and(eltType, numElts, x.data,
                    Intrin.splat(eltType, numElts, y));
  }

  /*
    Implements ``SCALAR & VECTOR``

    See :proc:`Intrin.and` for the intrinsic used.
  */
  inline operator&(x: ?scalarType, y: vector(?eltType, ?numElts)): y.type
    where isCoercible(scalarType, eltType) {
    var result: y.type;
    result.data = Intrin.and(eltType, numElts,
                    Intrin.splat(eltType, numElts, x), y.data);
    return result;
  }

  /*
    Implements ``VECTOR | VECTOR``

    See :proc:`Intrin.or` for the intrinsic used.
  */
  inline operator|(x: vector(?eltType, ?numElts), y: x.type): x.type {
    var result: x.type;
    result.data = Intrin.or(eltType, numElts, x.data, y.data);
    return result;
  }

  /*
    Implements ``VECTOR |= VECTOR``

    See :proc:`Intrin.or` for the intrinsic used.
  */
  inline operator|=(ref x: vector(?eltType, ?numElts), y: x.type) {
    x.data = Intrin.or(eltType, numElts, x.data, y.data);
  }

  /*
    Implements ``VECTOR | SCALAR``

    See :proc:`Intrin.or` for the intrinsic used.
  */
  inline operator|(x: vector(?eltType, ?numElts), y: ?scalarType): x.type
    where isCoercible(scalarType, eltType) {
    var result: x.type;
    result.data = Intrin.or(eltType, numElts, x.data,
                    Intrin.splat(eltType, numElts, y));
    return result;
  }

  /*
    Implements ``VECTOR |= SCALAR``

    See :proc:`Intrin.or` for the intrinsic used.
  */
  inline operator|=(ref x: vector(?eltType, ?numElts), y: ?scalarType)
    where isCoercible(scalarType, eltType) {
    x.data = Intrin.or(eltType, numElts, x.data,
                    Intrin.splat(eltType, numElts, y));
  }

  /*
    Implements ``SCALAR | VECTOR``

    See :proc:`Intrin.or` for the intrinsic used.
  */
  inline operator|(x: ?scalarType, y: vector(?eltType, ?numElts)): y.type
    where isCoercible(scalarType, eltType) {
    var result: y.type;
    result.data = Intrin.or(eltType, numElts,
                    Intrin.splat(eltType, numElts, x), y.data);
    return result;
  }

  /*
    Implements ``VECTOR ^ VECTOR``

    See :proc:`Intrin.xor` for the intrinsic used.
  */
  inline operator^(x: vector(?eltType, ?numElts), y: x.type): x.type {
    var result: x.type;
    result.data = Intrin.xor(eltType, numElts, x.data, y.data);
    return result;
  }

  /*
    Implements ``VECTOR ^= VECTOR``

    See :proc:`Intrin.xor` for the intrinsic used.
  */
  inline operator^=(ref x: vector(?eltType, ?numElts), y: x.type) {
    x.data = Intrin.xor(eltType, numElts, x.data, y.data);
  }

  /*
    Implements ``VECTOR ^ SCALAR``

    See :proc:`Intrin.xor` for the intrinsic used.
  */
  inline operator^(x: vector(?eltType, ?numElts), y: ?scalarType): x.type
    where isCoercible(scalarType, eltType) {
    var result: x.type;
    result.data = Intrin.xor(eltType, numElts, x.data,
                    Intrin.splat(eltType, numElts, y));
    return result;
  }

  /*
    Implements ``VECTOR ^= SCALAR``

    See :proc:`Intrin.xor` for the intrinsic used.
  */
  inline operator^=(ref x: vector(?eltType, ?numElts), y: ?scalarType)
    where isCoercible(scalarType, eltType) {
    x.data = Intrin.xor(eltType, numElts, x.data,
                    Intrin.splat(eltType, numElts, y));
  }

  /*
    Implements ``SCALAR ^ VECTOR``

    See :proc:`Intrin.xor` for the intrinsic used.
  */
  inline operator^(x: ?scalarType, y: vector(?eltType, ?numElts)): y.type
    where isCoercible(scalarType, eltType) {
    var result: y.type;
    result.data = Intrin.xor(eltType, numElts,
                    Intrin.splat(eltType, numElts, x), y.data);
    return result;
  }

  /*
    Implements ``VECTOR ~``

    See :proc:`Intrin.not` for the intrinsic used.
  */
  inline operator~(x: vector(?eltType, ?numElts)): x.type {
    var result: x.type;
    result.data = Intrin.not(eltType, numElts, x.data);
    return result;
  }

  /*
    Implements ``VECTOR == VECTOR``

    See :proc:`Intrin.cmpEq` for the intrinsic used.
  */
  inline operator==(x: vector(?eltType, ?numElts), y: x.type): x.type {
    var result: x.type;
    result.data = Intrin.cmpEq(eltType, numElts, x.data, y.data);
    return result;
  }

  /*
    Implements ``VECTOR == SCALAR``

    See :proc:`Intrin.cmpEq` for the intrinsic used.
  */
  inline operator==(x: vector(?eltType, ?numElts), y: ?scalarType): x.type
    where isCoercible(scalarType, eltType) {
    var result: x.type;
    result.data = Intrin.cmpEq(eltType, numElts, x.data,
                    Intrin.splat(eltType, numElts, y));
    return result;
  }

  /*
    Implements ``SCALAR == VECTOR``

    See :proc:`Intrin.cmpEq` for the intrinsic used.
  */
  inline operator==(x: ?scalarType, y: vector(?eltType, ?numElts)): y.type
    where isCoercible(scalarType, eltType) {
    var result: y.type;
    result.data = Intrin.cmpEq(eltType, numElts,
                    Intrin.splat(eltType, numElts, x), y.data);
    return result;
  }

  /*
    Implements ``VECTOR != VECTOR``

    See :proc:`Intrin.cmpNe` for the intrinsic used.
  */
  inline operator!=(x: vector(?eltType, ?numElts), y: x.type): x.type {
    var result: x.type;
    result.data = Intrin.cmpNe(eltType, numElts, x.data, y.data);
    return result;
  }

  /*
    Implements ``VECTOR != SCALAR``

    See :proc:`Intrin.cmpNe` for the intrinsic used.
  */
  inline operator!=(x: vector(?eltType, ?numElts), y: ?scalarType): x.type
    where isCoercible(scalarType, eltType) {
    var result: x.type;
    result.data = Intrin.cmpNe(eltType, numElts, x.data,
                    Intrin.splat(eltType, numElts, y));
    return result;
  }

  /*
    Implements ``SCALAR != VECTOR``

    See :proc:`Intrin.cmpNe` for the intrinsic used.
  */
  inline operator!=(x: ?scalarType, y: vector(?eltType, ?numElts)): y.type
    where isCoercible(scalarType, eltType) {
    var result: y.type;
    result.data = Intrin.cmpNe(eltType, numElts,
                    Intrin.splat(eltType, numElts, x), y.data);
    return result;
  }

  /*
    Implements ``VECTOR < VECTOR``

    See :proc:`Intrin.cmpLt` for the intrinsic used.
  */
  inline operator<(x: vector(?eltType, ?numElts), y: x.type): x.type {
    var result: x.type;
    result.data = Intrin.cmpLt(eltType, numElts, x.data, y.data);
    return result;
  }

  /*
    Implements ``VECTOR < SCALAR``

    See :proc:`Intrin.cmpLt` for the intrinsic used.
  */
  inline operator<(x: vector(?eltType, ?numElts), y: ?scalarType): x.type
    where isCoercible(scalarType, eltType) {
    var result: x.type;
    result.data = Intrin.cmpLt(eltType, numElts, x.data,
                    Intrin.splat(eltType, numElts, y));
    return result;
  }

  /*
    Implements ``SCALAR < VECTOR``

    See :proc:`Intrin.cmpLt` for the intrinsic used.
  */
  inline operator<(x: ?scalarType, y: vector(?eltType, ?numElts)): y.type
    where isCoercible(scalarType, eltType) {
    var result: y.type;
    result.data = Intrin.cmpLt(eltType, numElts,
                    Intrin.splat(eltType, numElts, x), y.data);
    return result;
  }

  /*
    Implements ``VECTOR <= VECTOR``

    See :proc:`Intrin.cmpLe` for the intrinsic used.
  */
  inline operator<=(x: vector(?eltType, ?numElts), y: x.type): x.type {
    var result: x.type;
    result.data = Intrin.cmpLe(eltType, numElts, x.data, y.data);
    return result;
  }

  /*
    Implements ``VECTOR <= SCALAR``

    See :proc:`Intrin.cmpLe` for the intrinsic used.
  */
  inline operator<=(x: vector(?eltType, ?numElts), y: ?scalarType): x.type
    where isCoercible(scalarType, eltType) {
    var result: x.type;
    result.data = Intrin.cmpLe(eltType, numElts, x.data,
                    Intrin.splat(eltType, numElts, y));
    return result;
  }

  /*
    Implements ``SCALAR <= VECTOR``

    See :proc:`Intrin.cmpLe` for the intrinsic used.
  */
  inline operator<=(x: ?scalarType, y: vector(?eltType, ?numElts)): y.type
    where isCoercible(scalarType, eltType) {
    var result: y.type;
    result.data = Intrin.cmpLe(eltType, numElts,
                    Intrin.splat(eltType, numElts, x), y.data);
    return result;
  }

  /*
    Implements ``VECTOR > VECTOR``

    See :proc:`Intrin.cmpGt` for the intrinsic used.
  */
  inline operator>(x: vector(?eltType, ?numElts), y: x.type): x.type {
    var result: x.type;
    result.data = Intrin.cmpGt(eltType, numElts, x.data, y.data);
    return result;
  }

  /*
    Implements ``VECTOR > SCALAR``

    See :proc:`Intrin.cmpGt` for the intrinsic used.
  */
  inline operator>(x: vector(?eltType, ?numElts), y: ?scalarType): x.type
    where isCoercible(scalarType, eltType) {
    var result: x.type;
    result.data = Intrin.cmpGt(eltType, numElts, x.data,
                    Intrin.splat(eltType, numElts, y));
    return result;
  }

  /*
    Implements ``SCALAR > VECTOR``

    See :proc:`Intrin.cmpGt` for the intrinsic used.
  */
  inline operator>(x: ?scalarType, y: vector(?eltType, ?numElts)): y.type
    where isCoercible(scalarType, eltType) {
    var result: y.type;
    result.data = Intrin.cmpGt(eltType, numElts,
                    Intrin.splat(eltType, numElts, x), y.data);
    return result;
  }

  /*
    Implements ``VECTOR >= VECTOR``

    See :proc:`Intrin.cmpGe` for the intrinsic used.
  */
  inline operator>=(x: vector(?eltType, ?numElts), y: x.type): x.type {
    var result: x.type;
    result.data = Intrin.cmpGe(eltType, numElts, x.data, y.data);
    return result;
  }

  /*
    Implements ``VECTOR >= SCALAR``

    See :proc:`Intrin.cmpGe` for the intrinsic used.
  */
  inline operator>=(x: vector(?eltType, ?numElts), y: ?scalarType): x.type
    where isCoercible(scalarType, eltType) {
    var result: x.type;
    result.data = Intrin.cmpGe(eltType, numElts, x.data,
                    Intrin.splat(eltType, numElts, y));
    return result;
  }

  /*
    Implements ``SCALAR >= VECTOR``

    See :proc:`Intrin.cmpGe` for the intrinsic used.
  */
  inline operator>=(x: ?scalarType, y: vector(?eltType, ?numElts)): y.type
    where isCoercible(scalarType, eltType) {
    var result: y.type;
    result.data = Intrin.cmpGe(eltType, numElts,
                    Intrin.splat(eltType, numElts, x), y.data);
    return result;
  }
}
